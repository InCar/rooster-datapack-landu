package com.incarcloud.rooster.datapack;

import io.netty.buffer.ByteBuf;
import io.netty.buffer.ByteBufUtil;
import io.netty.buffer.Unpooled;
import org.junit.After;
import org.junit.Assert;
import org.junit.Before;
import org.junit.Test;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import javax.xml.bind.DatatypeConverter;
import java.util.List;

/**
 * Test DataParserLANDU class
 *
 * @author Aaric
 * @since 2.0
 */
public class DataParserLanduTest {

    private static Logger s_logger = LoggerFactory.getLogger(DataParserLanduTest.class);

    private ByteBuf buffer;

    @Before
    public void begin() {
        // 测试数据
        byte[] data = {
                (byte) 0xAA, 0x55, //2字节-数据包标志(AA55)
                0x01, (byte) 0xF6, //2字节-数据包长度
                (byte) 0xFE, 0x09, //2字节-数据包长度校验(数据包长度取反)
                0x1C, //1字节-数据包ID
                0x05, //1字节-保留字节(协议格式版本, v2.05-0x02, v3.08-0x05)
                0x16, 0x06, 0x31, 0x32, 0x37, 0x33, 0x37, 0x36, 0x34, 0x36, 0x00, 0x00, 0x00, 0x00, 0x6E, 0x31, 0x34, 0x35, 0x30, 0x39, 0x00, 0x31, 0x43, 0x33, 0x48, 0x38, 0x42, 0x33, 0x47, 0x33, 0x36, 0x59, 0x31, 0x30, 0x39, 0x36, 0x39, 0x35, 0x00, 0x00, 0x08, 0x35, 0x32, 0x00, 0x33, 0x33, 0x39, 0x34, 0x00, 0x45, 0x31, 0x31, 0x33, 0x2E, 0x32, 0x33, 0x38, 0x37, 0x31, 0x31, 0x2C, 0x4E, 0x32, 0x33, 0x2E, 0x30, 0x39, 0x38, 0x30, 0x31, 0x31, 0x2C, 0x32, 0x34, 0x36, 0x2C, 0x32, 0x30, 0x31, 0x37, 0x2D, 0x30, 0x35, 0x2D, 0x32, 0x37, 0x20, 0x30, 0x30, 0x3A, 0x34, 0x38, 0x3A, 0x35, 0x36, 0x2C, 0x32, 0x00, 0x33, 0x38, 0x00, 0x33, 0x35, 0x32, 0x30, 0x00, 0x45, 0x31, 0x31, 0x33, 0x2E, 0x32, 0x33, 0x37, 0x35, 0x36, 0x39, 0x2C, 0x4E, 0x32, 0x33, 0x2E, 0x30, 0x39, 0x37, 0x35, 0x32, 0x31, 0x2C, 0x32, 0x35, 0x32, 0x2C, 0x32, 0x30, 0x31, 0x37, 0x2D, 0x30, 0x35, 0x2D, 0x32, 0x37, 0x20, 0x30, 0x30, 0x3A, 0x34, 0x39, 0x3A, 0x30, 0x35, 0x2C, 0x32, 0x00, 0x36, 0x00, 0x33, 0x35, 0x38, 0x31, 0x00, 0x45, 0x31, 0x31, 0x33, 0x2E, 0x32, 0x33, 0x36, 0x39, 0x33, 0x37, 0x2C, 0x4E, 0x32, 0x33, 0x2E, 0x30, 0x39, 0x37, 0x33, 0x30, 0x35, 0x2C, 0x30, 0x2C, 0x32, 0x30, 0x31, 0x37, 0x2D, 0x30, 0x35, 0x2D, 0x32, 0x37, 0x20, 0x30, 0x30, 0x3A, 0x34, 0x39, 0x3A, 0x32, 0x32, 0x2C, 0x32, 0x00, 0x31, 0x30, 0x00, 0x33, 0x35, 0x38, 0x33, 0x00, 0x45, 0x31, 0x31, 0x33, 0x2E, 0x32, 0x33, 0x36, 0x39, 0x33, 0x30, 0x2C, 0x4E, 0x32, 0x33, 0x2E, 0x30, 0x39, 0x37, 0x33, 0x30, 0x34, 0x2C, 0x32, 0x34, 0x36, 0x2C, 0x32, 0x30, 0x31, 0x37, 0x2D, 0x30, 0x35, 0x2D, 0x32, 0x37, 0x20, 0x30, 0x30, 0x3A, 0x34, 0x39, 0x3A, 0x32, 0x33, 0x2C, 0x32, 0x00, 0x33, 0x35, 0x00, 0x33, 0x36, 0x37, 0x31, 0x00, 0x45, 0x31, 0x31, 0x33, 0x2E, 0x32, 0x33, 0x36, 0x35, 0x32, 0x39, 0x2C, 0x4E, 0x32, 0x33, 0x2E, 0x30, 0x39, 0x36, 0x38, 0x36, 0x34, 0x2C, 0x31, 0x36, 0x36, 0x2C, 0x32, 0x30, 0x31, 0x37, 0x2D, 0x30, 0x35, 0x2D, 0x32, 0x37, 0x20, 0x30, 0x30, 0x3A, 0x34, 0x39, 0x3A, 0x33, 0x35, 0x2C, 0x32, 0x00, 0x32, 0x36, 0x00, 0x33, 0x37, 0x34, 0x38, 0x00, 0x45, 0x31, 0x31, 0x33, 0x2E, 0x32, 0x33, 0x36, 0x37, 0x30, 0x34, 0x2C, 0x4E, 0x32, 0x33, 0x2E, 0x30, 0x39, 0x36, 0x32, 0x39, 0x39, 0x2C, 0x31, 0x35, 0x38, 0x2C, 0x32, 0x30, 0x31, 0x37, 0x2D, 0x30, 0x35, 0x2D, 0x32, 0x37, 0x20, 0x30, 0x30, 0x3A, 0x34, 0x39, 0x3A, 0x34, 0x36, 0x2C, 0x32, 0x00, 0x34, 0x32, 0x00, 0x33, 0x38, 0x33, 0x35, 0x00, 0x45, 0x31, 0x31, 0x33, 0x2E, 0x32, 0x33, 0x36, 0x39, 0x35, 0x36, 0x2C, 0x4E, 0x32, 0x33, 0x2E, 0x30, 0x39, 0x35, 0x36, 0x32, 0x37, 0x2C, 0x31, 0x35, 0x35, 0x2C, 0x32, 0x30, 0x31, 0x37, 0x2D, 0x30, 0x35, 0x2D, 0x32, 0x37, 0x20, 0x30, 0x30, 0x3A, 0x34, 0x39, 0x3A, 0x35, 0x35, 0x2C, 0x32, 0x00, 0x35, 0x31, 0x00, 0x33, 0x39, 0x34, 0x39, 0x00, 0x45, 0x31, 0x31, 0x33, 0x2E, 0x32, 0x33, 0x37, 0x34, 0x35, 0x32, 0x2C, 0x4E, 0x32, 0x33, 0x2E, 0x30, 0x39, 0x34, 0x36, 0x32, 0x36, 0x2C, 0x31, 0x35, 0x35, 0x2C, 0x32, 0x30, 0x31, 0x37, 0x2D, 0x30, 0x35, 0x2D, 0x32, 0x37, 0x20, 0x30, 0x30, 0x3A, 0x35, 0x30, 0x3A, 0x30, 0x34, 0x2C, 0x32, 0x00,
                0x5F, 0x0E //2字节-校验和(【数据包长度】开始至全部【数据内容】结束止的所有字节产累加之和)
        };
        buffer = Unpooled.wrappedBuffer(data);
    }

    @After
    public void end() {
        //Assert.assertEquals(0, buffer.refCnt());
        buffer.release();
    }

    @Test
    public void testReverseByteArray() throws Exception {
        byte tmp;
        byte[] bytes = {(byte) 0xFF,(byte) 0xB4};
        for(int i = 0; i < bytes.length; i++) {
            tmp = bytes[i];
            bytes[i] = (byte) ~tmp;
        }
        Assert.assertEquals("004b", ByteBufUtil.hexDump(bytes));
    }

    @Test
    public void testByteArrayToInt() throws Exception {
        byte[] bytes = {0x00, 0x4B};
        Assert.assertEquals(75, (bytes[0] & 0xFF) << 8 | (bytes[1] & 0xFF));
    }

    @Test
    public void testExtract() throws Exception {
        IDataParser parser = new DataParserLandu();
        List<DataPack> dataPackList = parser.extract(buffer);
        Assert.assertEquals(1, dataPackList.size());

        for(DataPack dataPack: dataPackList) {
            dataPack.freeBuf();
        }
    }

    @Test
    public void testCreateResponse() {
        IDataParser parser = new DataParserLandu();
        ByteBuf responseBuf = parser.createResponse(parser.extract(buffer).get(0), ERespReason.OK);
        Assert.assertEquals("AA55000BFFF41C05160600023B", DatatypeConverter.printHexBinary(ByteBufUtil.getBytes(responseBuf, 0, responseBuf.readableBytes())));
    }
}
